#include <ndt_registration/ndt_matcher_d2d_sc.h>
#include <ndt_generic/motion_model_3d.h>
#include <ndt_generic/io.h>
#include <ndt_map/pointcloud_utils.h>
#include <boost/program_options.hpp>

using namespace std;


class NDTD2DSCScore 
{
public:
    Eigen::Affine3d offset;
    double score_d2d;
    double score_d2d_sc;
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
};

// To evaluate the objective function with and without soft constraints, to interface the files generated by the offline fuser
class NDTD2DSCScoreEval 
{
public:
    
    NDTD2DSCScoreEval(const std::string &gt_file,
                      const std::string &odom_file,
                      const std::string &base_name_pcd,
                      const Eigen::Affine3d &sensor_pose,
                      const lslgeneric::MotionModel3d::Params &motion_params) : base_name_pcd_(base_name_pcd), sensor_pose_(sensor_pose) {
        
        
        std::cout << "loading: " << gt_file << std::endl;
        Tgt = ndt_generic::loadAffineFromEvalFile(gt_file);
        std::cout << " got # poses : " << Tgt.size() << std::endl;
        std::cout << "loading: " << odom_file << std::endl;
        Todom = ndt_generic::loadAffineFromEvalFile(odom_file);
        std::cout << " got #poses : " << Todom.size() << std::endl;
        
        motion_model.setParams(motion_params);
        resolution = 1.;
        alpha_ = 1.;

        offset_size = 100;
        incr_dist = 0.01;
        incr_ang = 0.002;
    }
    
    std::vector<Eigen::Affine3d> generateOffsetSet() {
        
        std::vector<Eigen::Affine3d> ret;
        std::vector<double> incr(6);
        incr.resize(6);

        for (int i = 0; i < 3; i++) {
            incr[i] = incr_dist;
            incr[i+3] = incr_ang;
        }
        
        Eigen::VectorXd offset(6);
        for (int j = 0; j < 6; j++) {
            offset.setZero();
            for (int i = -offset_size; i < offset_size; i++) {
                offset[j] = i*incr[j];
                ret.push_back(ndt_generic::vectorToAffine3d(offset));
            }
            
        }
        return ret;
    }
    
    std::vector<Eigen::Affine3d> generateOffset2DSet(int dimidx1, int dimidx2) {
        
        std::vector<Eigen::Affine3d> ret;
        std::vector<double> incr(6);
        incr.resize(6);

        for (int i = 0; i < 3; i++) {
            incr[i] = incr_dist;
            incr[i+3] = incr_ang;
        }
        
        Eigen::VectorXd offset(6);
        offset.setZero();
        for (int j = -offset_size ; j <= offset_size; j++) {
            offset[dimidx1] = j*incr[dimidx1];
            for (int i = -offset_size; i <= offset_size; i++) {
                offset[dimidx2] = i*incr[dimidx2];
                ret.push_back(ndt_generic::vectorToAffine3d(offset));
            }
        }
        return ret;
    }
    


    void computeScoreSets(int idx1, int idx2, int dimidx1, int dimidx2) {
        
        // The pcd is given in sensor frame...
        pcl::PointCloud<pcl::PointXYZ> pc1, pc2;
        ndt_generic::loadCloud(base_name_pcd_, idx1, pc1);
        ndt_generic::loadCloud(base_name_pcd_, idx2, pc2);
        
        if (pc1.empty() || pc2.empty()) {
            std::cerr << "no points(!) found" << std::endl;
            return;
        }
        
        std::cout << "loaded pc1 # points : " << pc1.size() << std::endl;
        std::cout << "loaded pc2 # points : " << pc2.size() << std::endl;
        std::cout << "Sensor pose used : " << ndt_generic::affine3dToStringRotMat(sensor_pose_);

        // Work in the vehicle frame... move the points
        lslgeneric::transformPointCloudInPlace(sensor_pose_, pc1);
        lslgeneric::transformPointCloudInPlace(sensor_pose_, pc2);

        // Compute the ndtmap
        lslgeneric::NDTMap nd1(new lslgeneric::LazyGrid(resolution), true);
        nd1.loadPointCloud(pc1);
        nd1.computeNDTCellsSimple();
        
        lslgeneric::NDTMap nd2(new lslgeneric::LazyGrid(resolution), true);
        nd2.loadPointCloud(pc2);
        nd2.computeNDTCellsSimple();
        
        // Relative odometry
        T_rel_odom_ = Todom[idx1].inverse() * Todom[idx2];
        
        std::cout << "T_rel_odom : " << ndt_generic::affine3dToStringRPY(T_rel_odom_) << std::endl;

        // Compute the covariance
        Eigen::MatrixXd Tcov = motion_model.getCovMatrix(T_rel_odom_); 
       
        lslgeneric::NDTMatcherD2DSC matcher_d2d_sc;
        
        std::vector<Eigen::Affine3d> Ts = generateOffset2DSet(dimidx1,dimidx2);
        results.resize(Ts.size());
        
        for (int i = 0; i < Ts.size(); i++) {
            double score_d2d, score_d2d_sc;
            std::cout << "." << std::flush;
            matcher_d2d_sc.scoreComparision(nd1, nd2, T_rel_odom_, Tcov, score_d2d, score_d2d_sc, Ts[i], alpha_);
            results[i].offset = Ts[i];
            results[i].score_d2d = score_d2d;
            results[i].score_d2d_sc = score_d2d_sc;
        }
        
        // Compute matches
        lslgeneric::NDTMatcherD2D matcher_d2d;
        T_d2d_ = T_rel_odom_;
        T_d2d_sc_ = T_rel_odom_;
        matcher_d2d.match(nd1, nd2, T_d2d_, true);
        matcher_d2d_sc.match(nd1, nd2, T_d2d_sc_, Tcov);
      

        // Compute a "filtered" match - based on the d2d output and odometry weighed by the covariances.
        Eigen::MatrixXd T_d2d_cov(6,6);
        matcher_d2d.covariance(nd1, nd2, T_d2d_, T_d2d_cov);

        std::cout << "T_d2d_cov : " << T_d2d_cov << std::endl;

        T_filter_ = ndt_generic::getWeightedPose(T_rel_odom_, Tcov, T_d2d_, T_d2d_cov);

        // Update the relative transform.
        T_rel_gt_ = Tgt[idx1].inverse() * Tgt[idx2];
    }
    
    void save(const std::string &filename, int grididx) const {

        std::cout << "saving to : " << filename << std::endl;
        // Save the output for plotting...
        std::ofstream ofs;
        ofs.open(filename.c_str());
        if (!ofs.is_open())
            return;
        
        for (int i = 0; i < results.size(); i++) {
            ofs << ndt_generic::affine3dToStringRPY(results[i].offset) << " " << results[i].score_d2d << " " << results[i].score_d2d_sc << std::endl;

            // for gnuplot - if you want to plot a grid you need to throw in some blank lines
            if (i < results.size()-1) {
                if (results[i].offset.translation()[grididx] !=
                    results[i+1].offset.translation()[grididx]) {
                    ofs << std::endl;
                }
            }
        }
        ofs.close();
    }

    // Save in a 2d grid, to be able to plot a 2d grid with different colors (gnuplot pm3d)
    void save2D(const std::string &filename, int dimidx1, int dimidx2) const {

        std::cout << "saving to : " << filename << std::endl;
        // Save the output for plotting...
        std::ofstream ofs;
        ofs.open(filename.c_str());
        if (!ofs.is_open())
            return;
        
        for (int i = 0; i < results.size(); i++) {
            Eigen::VectorXd x = ndt_generic::affine3dToVector(results[i].offset);
            ofs << x[dimidx1] << " " << x[dimidx2] << " " << results[i].score_d2d << " " << results[i].score_d2d_sc << std::endl;

            // for gnuplot - if you want to plot a grid you need to throw in some blank lines
            if (i < results.size()-1) {
                if (results[i].offset.translation()[dimidx1] !=
                    results[i+1].offset.translation()[dimidx1]) {
                    ofs << std::endl;
                }
            }
        }
        ofs.close();

    }

    // Saves in the same frame as with the offset is used (the odometry frame)
    void savePoseEst(const std::string &filename) const {
        // ofs << ndt_generic::affine3dToStringRPY(T_rel_odom_.inverse()*T_rel_gt_) << " " 
        //     << ndt_generic::affine3dToStringRPY(T_rel_odom_.inverse()*T_d2d_) << " "
        //     << ndt_generic::affine3dToStringRPY(T_rel_odom_.inverse()*T_d2d_sc_) << " "
        //     << ndt_generic::affine3dToStringRPY(T_rel_odom_.inverse()*T_filter_) << std::endl;
        ndt_generic::saveAffine3dRPY(filename + std::string(".gt"), T_rel_odom_.inverse()*T_rel_gt_);
        ndt_generic::saveAffine3dRPY(filename + std::string(".d2d"), T_rel_odom_.inverse()*T_d2d_);
        ndt_generic::saveAffine3dRPY(filename + std::string(".d2d_sc"), T_rel_odom_.inverse()*T_d2d_sc_);
        ndt_generic::saveAffine3dRPY(filename + std::string(".filter"), T_rel_odom_.inverse()*T_filter_);
        ndt_generic::saveAffine3dRPY(filename + std::string(".odom"), T_rel_odom_.inverse()*T_rel_odom_);
    }

    
    // Parameters
    double resolution; // resolution for the ndt map

    int offset_size;
    double incr_dist;
    double incr_ang;
    
private:
    std::vector<Eigen::Affine3d> Todom;
    std::vector<Eigen::Affine3d> Tgt;

    std::string base_name_pcd_;
    Eigen::Affine3d sensor_pose_;

    lslgeneric::MotionModel3d motion_model;
    
    
    std::vector<NDTD2DSCScore> results;
    double alpha_;

    Eigen::Affine3d T_d2d_;
    Eigen::Affine3d T_d2d_sc_;
    Eigen::Affine3d T_filter_;
    Eigen::Affine3d T_rel_gt_;
    Eigen::Affine3d T_rel_odom_;

};


namespace po = boost::program_options;

int main(int argc, char** argv)
{
    cout << "--------------------------------------------------" << endl;
    cout << "Creates a set of gnuplot files to visualize " << endl;
    cout << "different scores of matching functions" << std::endl;
    cout << "--------------------------------------------------" << endl;

    po::options_description desc("Allowed options");
    std::string gt_file;
    std::string odom_file;
    std::string base_name_pcd;    
    Eigen::Vector3d transl;
    Eigen::Vector3d euler;
    double resolution;
    int idx1, idx2;
    int dimidx1, dimidx2;
    int offset_size;
    double incr_dist;
    double incr_ang;
    std::string out_file;
    // Simply to make it transparant to the fuser node.
    lslgeneric::MotionModel2d::Params motion_params;


    desc.add_options()
        ("help", "produce help message")
	("gt_file", po::value<std::string>(&gt_file), "vehicle pose files in world frame")
	("odom_file", po::value<std::string>(&odom_file)->default_value(std::string("")), "estimated sensor poses (from egomotion) to be used in SC in world frame")
	("base_name_pcd", po::value<string>(&base_name_pcd)->default_value(std::string("")), "prefix for the .pcd files")
        ("out_file", po::value<string>(&out_file)->default_value(std::string("scores")), "prefix for the output files")
        ("idx1", po::value<int>(&idx1)->default_value(0), "'fixed' index of pose/pointcloud to be used")
        ("idx2", po::value<int>(&idx2)->default_value(1), "'moving' index of pose/pointcloud to be used")
        ("dimidx1", po::value<int>(&dimidx1)->default_value(0), "dimension index_x (what to plot on the X axis in gnuplot - 0,1,2,3,4,5 -> x,y,z,roll,pitch,yaw)")
        ("dimidx2", po::value<int>(&dimidx2)->default_value(1), "dimension index_y (what to plot on the Y axis in gnuplot - 0,1,2,3,4,5 -> x,y,z,roll,pitch,yaw)")
    
        ("x", po::value<double>(&transl[0])->default_value(0.), "sensor pose - translation vector x")
	("y", po::value<double>(&transl[1])->default_value(0.), "sensor pose - translation vector y")
	("z", po::value<double>(&transl[2])->default_value(0.), "sensor pose - translation vector z")
	("ex", po::value<double>(&euler[0])->default_value(0.), "sensor pose - euler angle vector x")
	("ey", po::value<double>(&euler[1])->default_value(0.), "sensor pose - euler angle vector y")
	("ez", po::value<double>(&euler[2])->default_value(0.), "sensor pose - euler angle vector z")
        ("resolution", po::value<double>(&resolution)->default_value(1.), "resolution of the map")
        ("offset_size", po::value<int>(&offset_size)->default_value(100), "2*number of evaluated points per dimension")
        ("incr_dist", po::value<double>(&incr_dist)->default_value(0.01), "incremental steps for distance directions (x,y,z)")
        ("incr_ang", po::value<double>(&incr_ang)->default_value(0.002), "incremental steps for angular directions (R,P,Y)")

        ("Dd", po::value<double>(&motion_params.Dd)->default_value(1.), "forward uncertainty on distance traveled")
        ("Dt", po::value<double>(&motion_params.Dt)->default_value(1.), "forward uncertainty on rotation")
        ("Cd", po::value<double>(&motion_params.Cd)->default_value(1.), "side uncertainty on distance traveled")
        ("Ct", po::value<double>(&motion_params.Ct)->default_value(1.), "side uncertainty on rotation")
        ("Td", po::value<double>(&motion_params.Td)->default_value(1.), "rotation uncertainty on distance traveled")
        ("Tt", po::value<double>(&motion_params.Tt)->default_value(1.), "rotation uncertainty on rotation")

        ;
    
    po::variables_map vm;
    po::store(po::parse_command_line(argc, argv, desc), vm);
    po::notify(vm);

    if (vm.count("help"))
    {
	cout << desc << "\n";
	return 1;
    }
    if (odom_file.empty()) {
        cout << "odom_file not specified" << endl;
        return 1;
    }

    Eigen::Affine3d sensor_pose = ndt_generic::vectorsToAffine3d(transl,euler);
    std::cout << "Sensor pose used : " << ndt_generic::affine3dToStringRPY(sensor_pose) << std::endl;
   

    lslgeneric::MotionModel3d::Params motion_params3d(motion_params);

    std::cout << "Motion params used : " << motion_params3d << std::endl;

    NDTD2DSCScoreEval se(gt_file, odom_file, base_name_pcd, sensor_pose, motion_params);
    se.resolution = resolution;
    se.offset_size = offset_size;
    se.incr_dist = incr_dist;
    se.incr_ang = incr_ang;
    std::cout << "computing scores" << std::endl;
    se.computeScoreSets(idx1, idx2, dimidx1, dimidx2);

    std::cout << "saving : " << out_file << std::endl;
    se.save2D(out_file + ".dat", dimidx1, dimidx2);
    se.savePoseEst(out_file + ".T");
    std::cout << "done." << std::endl;
}
