#pragma once

#include <vector>
#include <Eigen/Core>
#include <Eigen/Geometry>
#include <Eigen/Eigenvalues>
#include <angles/angles.h>
#include <iomanip>
#include <iostream>
#include <ndt_generic/utils.h>
#include <pcl/io/pcd_io.h>

namespace ndt_generic {

// Load the evaluation files that are generated by the fuser, <timestamp> x y x qx qy qz qw.
std::vector<Eigen::Affine3d> loadAffineFromEvalFile(const std::string &fileName) {
  std::vector<Eigen::Affine3d> ret;
  std::string line;
  std::ifstream myfile (fileName.c_str());
  if (myfile.is_open())
  {
    while ( getline (myfile,line) )
    {
      double time, x, y, z, qx, qy, qz, qw;
      std::istringstream ss(line);
      ss >> time >> x >> y >> z >> qx >> qy >> qz >> qw;
      ret.push_back(Eigen::Translation3d(x,y,z)*Eigen::Quaterniond(qw, qx, qy, qz));
    }
    myfile.close();
  }
  else {
    std::cout << "Unable to open file : " << fileName << std::endl;
  } 
  
  return ret;
}

// Load timestamps from the evaluation files that are generated by the fuser...
std::vector<double> loadTimeStampFromEvalFile(const std::string &fileName) {
  std::vector<double> ret;
  std::string line;
  std::ifstream myfile (fileName.c_str());
  if (myfile.is_open())
  {
    while ( getline (myfile,line) )
    {
      double time, x, y, z, qx, qy, qz, qw;
      std::istringstream ss(line);
      ss >> time >> x >> y >> z >> qx >> qy >> qz >> qw;
      ret.push_back(time);
   }
   myfile.close();
 }
  else std::cout << "Unable to open file : " << fileName << std::endl;; 
  
  return ret;
}


// Useful to load a set of files
void loadCloud(const std::string &base_name_pcd, int counter, pcl::PointCloud<pcl::PointXYZ> &cloud) {
    std::string pcd_file = base_name_pcd + std::string("cloud") + ndt_generic::toString(counter) + std::string(".pcd");
    std::cout << "loading : " << pcd_file << std::endl;
    pcl::io::loadPCDFile<pcl::PointXYZ>(pcd_file, cloud);
}


void saveAffine3dRPY(const std::string &filename, const Eigen::Affine3d &T) {
    std::ofstream ofs;
    ofs.open(filename.c_str());
    if (!ofs.is_open())
        return;
    ofs << ndt_generic::affine3dToStringRPY(T) << std::endl;
    ofs.close();
}





} // namespace
