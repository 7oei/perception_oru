#pragma once

#include <vector>
#include <Eigen/Core>
#include <Eigen/Geometry>
#include <Eigen/Eigenvalues>
#include <angles/angles.h>
#include <iomanip>
#include <iostream>
#include <ndt_generic/utils.h>
#include <pcl/io/pcd_io.h>

namespace ndt_generic {

// Load the evaluation files that are generated by the fuser, <timestamp> x y x qx qy qz qw.
std::vector<Eigen::Affine3d> loadAffineFromEvalFile(const std::string &fileName) {
  std::vector<Eigen::Affine3d> ret;
  std::string line;
  std::ifstream myfile (fileName.c_str());
  if (myfile.is_open())
  {
    while ( getline (myfile,line) )
    {
      double time, x, y, z, qx, qy, qz, qw;
      std::istringstream ss(line);
      ss >> time >> x >> y >> z >> qx >> qy >> qz >> qw;
      ret.push_back(Eigen::Translation3d(x,y,z)*Eigen::Quaterniond(qw, qx, qy, qz));
    }
    myfile.close();
  }
  else {
    std::cout << "Unable to open file : " << fileName << std::endl;
  } 
  
  return ret;
}

// Load timestamps from the evaluation files that are generated by the fuser...
std::vector<double> loadTimeStampFromEvalFile(const std::string &fileName) {
  std::vector<double> ret;
  std::string line;
  std::ifstream myfile (fileName.c_str());
  if (myfile.is_open())
  {
    while ( getline (myfile,line) )
    {
      double time, x, y, z, qx, qy, qz, qw;
      std::istringstream ss(line);
      ss >> time >> x >> y >> z >> qx >> qy >> qz >> qw;
      ret.push_back(time);
   }
   myfile.close();
 }
  else std::cout << "Unable to open file : " << fileName << std::endl;; 
  
  return ret;
}


// Useful to load a set of files
void loadCloud(const std::string &base_name_pcd, int counter, pcl::PointCloud<pcl::PointXYZ> &cloud) {
    std::string pcd_file = base_name_pcd + std::string("cloud") + ndt_generic::toString(counter) + std::string(".pcd");
    std::cout << "loading : " << pcd_file << std::endl;
    pcl::io::loadPCDFile<pcl::PointXYZ>(pcd_file, cloud);
}


void saveAffine3dRPY(const std::string &filename, const Eigen::Affine3d &T) {
    std::ofstream ofs;
    ofs.open(filename.c_str());
    if (!ofs.is_open())
        return;
    ofs << ndt_generic::affine3dToStringRPY(T) << std::endl;
    ofs.close();
}

// Save the evaluation files that are generated by the fuser, <timestamp> x y x qx qy qz qw.
// Timesamps are set to the index.
void saveAffineToEvalFile(const std::string &filename, const std::vector<Eigen::Affine3d> &Ts) {
    std::ofstream ofs;
    ofs.open(filename.c_str());
    if (!ofs.is_open())
        return;
    for (int i = 0; i < Ts.size(); i++) {
        ofs << i << " " << ndt_generic::transformToEvalString(Ts[i]);
    }
    ofs.close();
}


std::vector<double> loadDoubleVecTextFile(const std::string &fileName) {

   std::vector<double> vec;
   std::ifstream ifs;
   ifs.open(fileName.c_str());
   if (!ifs.is_open()) {
     std::cerr << __FILE__ << ":" << __LINE__ << " cannot open file : " << fileName << std::endl;
   }
    
   while (!ifs.eof())
     {
       std::string line;
       getline(ifs, line);
       
       double val;
       if (sscanf(line.c_str(), "%lf",
		  &val) == 1)
	 {
	   vec.push_back(val);
	 }
     }
   return vec;
 }

 void saveDoubleVecTextFile(const std::vector<double> &vec, const std::string &fileName)
 {
   std::stringstream st;
   st << fileName;
   std::string file_name = st.str();
   std::ofstream ofs(file_name.c_str());
   
   for (unsigned int i = 0; i < vec.size(); i++)
     {
       ofs << vec[i] << std::endl;
     }  
   ofs.close();
 }



} // namespace
